use std::{
    net::{IpAddr, Ipv4Addr},
    sync::Arc,
};

use futures::prelude::*;

use tarpc::{
    server::{incoming::Incoming, Channel},
    tokio_serde::formats::Bincode,
};

use crate::cluster::FlareNode;

use openraft::{
    error::{Infallible, InstallSnapshotError},
    raft::{
        AppendEntriesRequest, AppendEntriesResponse, InstallSnapshotRequest,
        InstallSnapshotResponse, VoteRequest, VoteResponse,
    },
};
use tarpc::context::Context;

use crate::{metadata::MetaTypeConfig, raft::RaftError};

#[tarpc::service]
pub trait RaftRpc {
    async fn vote(request: VoteRequest<u64>) -> Result<VoteResponse<u64>, FlareTarpcError>;
    async fn install_snapshot(
        request: InstallSnapshotRequest<MetaTypeConfig>,
    ) -> Result<InstallSnapshotResponse<u64>, FlareTarpcError<InstallSnapshotError>>;
    async fn append_entries(
        request: AppendEntriesRequest<MetaTypeConfig>,
    ) -> Result<AppendEntriesResponse<u64>, FlareTarpcError>;
}

#[derive(serde::Deserialize, serde::Serialize, thiserror::Error, Debug)]
pub enum FlareTarpcError<E = Infallible> {
    #[error("raft error")]
    RaftError(RaftError<E>),
    #[error("shard not found")]
    ShardNotFound,
}

#[derive(Clone)]
#[allow(dead_code)]
pub struct MetadataRaftRpcServer {
    flare_node: Arc<FlareNode>,
}

impl MetadataRaftRpcServer {
    pub fn new(flare_node: Arc<FlareNode>) -> Self {
        MetadataRaftRpcServer { flare_node }
    }
}

impl RaftRpc for MetadataRaftRpcServer {
    async fn vote(
        self,
        _context: Context,
        request: VoteRequest<u64>,
    ) -> Result<VoteResponse<u64>, FlareTarpcError> {
        let flare = self.flare_node.clone();
        let mm = flare.metadata_manager.clone();
        let result = mm
            .raft
            .vote(request)
            .await
            .map_err(|e| FlareTarpcError::RaftError(e))?;
        Ok(result)
    }

    async fn install_snapshot(
        self,
        _context: Context,
        request: InstallSnapshotRequest<MetaTypeConfig>,
    ) -> Result<InstallSnapshotResponse<u64>, FlareTarpcError<InstallSnapshotError>> {
        let flare = self.flare_node.clone();
        let mm = flare.metadata_manager.clone();
        let result = mm.raft.install_snapshot(request).await.map_err(
            |e: openraft::error::RaftError<u64, openraft::error::InstallSnapshotError>| {
                FlareTarpcError::RaftError(e)
            },
        )?;
        Ok(result)
    }

    async fn append_entries(
        self,
        _context: Context,
        request: AppendEntriesRequest<MetaTypeConfig>,
    ) -> Result<AppendEntriesResponse<u64>, FlareTarpcError> {
        let flare = self.flare_node.clone();
        let mm = flare.metadata_manager.clone();
        let result = mm
            .raft
            .append_entries(request)
            .await
            .map_err(|e| FlareTarpcError::RaftError(e))?;
        Ok(result)
    }
}

#[allow(dead_code)]
async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}

#[allow(dead_code)]
pub async fn start_server(
    flare: Arc<FlareNode>,
    port: u16,
) -> Result<(), Box<dyn std::error::Error>> {
    let server_addr = (IpAddr::V4(Ipv4Addr::LOCALHOST), port);

    // JSON transport is provided by the json_transport tarpc module. It makes it easy
    // to start up a serde-powered json serialization strategy over TCP.
    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Bincode::default).await?;
    tracing::info!("Listening on port {}", listener.local_addr().port());
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| futures::future::ready(r.ok()))
        .map(tarpc::server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = MetadataRaftRpcServer::new(flare.clone());
            channel.execute(server.serve()).for_each(spawn)
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;
    Ok(())
}
